"""
Module which handles importing questionnaires in special markdown dialect
using pandoc to process the input. Also see to_markdown functions on Question,
Asker etc for the reverse of this process.

This is somewhat a work in progress, and is for expert users only just now.

"""

import json
# note, the variable name is a hash of the text if undefined, and the default
# question type is an instruction
from hashlib import sha1

import ast
import re
from uuid import uuid1
from itertools import groupby, chain
from django.http import HttpResponseRedirect, HttpResponse
from django.core.urlresolvers import reverse
from ask.models import question
from django.contrib import messages
from signalbox.decorators import group_required
import floppyforms as forms
from django.shortcuts import render_to_response, get_object_or_404
from django.template import RequestContext
from ask.views.pandochelpers import stringify, get_meta_tuple
from ask.models import Asker, ChoiceSet, Question, AskPage, Choice, ShowIf
import envoy
import os

pandocpath = os.environ.get('PANDOC', None)


def get_or_modify(klass, lookups, params):
    """:: Klass -> Dict -> Dict -> (ClassObject, Bool)
    Takes
        - Class of the object
        - (id_field_name, id_value)
        - other params in a dictionary

    Returns
        - a new or modified object matching class + id, and with params set.
        - boolean indicating whether object was modified
          (modified objects are automatically saved)
    """
    ob, created = klass.objects.get_or_create(**lookups)
    mods = []
    klassfields = map(lambda x: getattr(x, "name"), klass.__dict__['_meta'].fields)
    for k, v in params.iteritems():
        if k in klassfields:  # ignore extra fields by default
            mods.append(not getattr(ob, k) == v)
            setattr(ob, k, v)
    modified = bool(sum(mods))
    ob.save()

    return ob, modified


# A series of lambdas to process pandoc's json

# spot and get key elements
iscodeblock = lambda x: bool("CodeBlock" in x)
ispagebreak = lambda x: "HorizontalRule" in x
getcodeblock = lambda x: x['CodeBlock']

# make codeblock lists generated by pandoc into more useful dictionaries
# note, the variable name is a hash of the text if undefined, and the default
# question type is an instruction
dictifycodeblock = lambda x: {'variable_name': x[0][0] or sha1(x[1]).hexdigest()[:10], 'classes': x[0][1], 'keyvals': dict(x[0][2]), 'text': x[1]}


# spot things once codeblock has been turned into dictionary
isquestion = lambda x: x and (bool("type" in x) or not x['classes'])
ischoiceset = lambda x: bool("choiceset" in x['classes'])

# split into a list of lists for pages
makepages = lambda doc: [list(i[1]) for i in groupby(doc, lambda x: ispagebreak(x)) if not i[0]]

# lifts specified items from a dictionary
pull_out_options = lambda x, keys: {k: v for k, v in x.items() if k in keys}

# apply a function to all values in a dictionary
dict_map = lambda f, d: {k: f(v) for k, v in d.items()}



def fix_showif_values(s):
    """Mainly used to identify lists in showif conditions"""
    try:
        return ast.literal_eval(s.strip())
    except:
        return s.strip()

# process textual showif conditions: use regex to split and
# make a dict containing variable_name, operator and value(s)
# note parens around operator split means the delimiter is retained
# in the result list
showif_to_dict = lambda s: dict_map(
    fix_showif_values,
    dict(zip("variable_name operator value".split(), re.split('(<|>|=|\sin\s)', s)))
)


def process_question_showif(question):
    if not question.get('showif', None):
        # do this to make sure the existing showif will get delinked
        question.update({'showif': None})
    else:
        showifdict = showif_to_dict(question['showif'])
        _fix_value = lambda v: isinstance(v, list) and ",".join(map(str, v)) or v and int(v) or None
        field_mapping = {
            '<': {'less_than': _fix_value(showifdict.get('value', None))},
            '>': {'more_than': _fix_value(showifdict.get('value', None))},
            '=': {'values': _fix_value(showifdict.get('value', None))},
            'in': {'values': _fix_value(showifdict.get('value', None))},
        }
        showifvalues = field_mapping[showifdict['operator']]
        showifvalues.update({'previous_question':
                get_or_modify(Question, {'variable_name': showifdict['variable_name']}, {})[0]})
        question.update({'showif': get_or_modify(ShowIf, showifvalues, {})[0]})


def _keyvalloader(x):
    try:
        return json.loads(x)
    except (TypeError, ValueError):
        return x


class MarkdownEditForm(forms.Form):

    markdown = forms.CharField(required=True,
        widget=forms.widgets.Textarea(attrs={'rows': 20}))

    def __init__(self, *args, **kwargs):
        asker = kwargs.pop('asker')
        initial = kwargs.get('initial', {})
        if not initial.get('markdown'):
            initial['markdown'] = asker.as_markdown()
        kwargs['initial'] = initial
        super(MarkdownEditForm, self).__init__(*args, **kwargs)

    def clean(self):
        data = self.cleaned_data
        j = envoy.run("""{} -t json""".format(pandocpath), data=data.get('markdown', "").encode('utf-8'))
        pandocjson = j.std_out

        pandocjson = json.loads(pandocjson)
        meta, doc = pandocjson

        # some of this processing is duplicated below in the save method
        # check if any variable names are duplicated
        items = map(dictifycodeblock, map(getcodeblock, filter(iscodeblock, doc)))
        _names = lambda x: (x.get('variable_name', None), bool(x.get('keyvals', {}).get('type', None)))
        names = map(_names, items)
        if len(names) != len(set(names)):
            raise forms.ValidationError("Duplicate variable names detected.")

        self.cleaned_data.update({"meta": meta, 'doc': doc})
        return self.cleaned_data

    def save(self, asker):

        items = map(getcodeblock, filter(iscodeblock, self.cleaned_data['doc']))

        # load and process meta data from yaml block
        meta = dict(filter(bool, map(get_meta_tuple, self.cleaned_data['meta']['unMeta'].items())))
        meta = {k: _keyvalloader(v) for k, v in meta.items()}

        def make_choiceset(block):
            "Function to process choiceset blocks into django objects"
            
            if not block.get('text', None):
                return []

            d = {'name': block['variable_name'], 'choices': [i.split("=") for i in block.get('text').split("\n")]}
            cs, modified = get_or_modify(ChoiceSet, {'name': d['name']}, {})
            cs.choice_set.all().delete()
            choices_with_defaults = [
                {"score": j[0].replace("*", ""),
                "is_default_value": bool("*" in j[0]),
                "label": j[1],
                "order": i,
                "choiceset": cs}
                    for i, j in enumerate(d.get('choices'))]

            choices = [Choice(**i) for i in choices_with_defaults]

            [i.save() for i in choices]

            return cs

        choicesets = map(make_choiceset,
                            filter(ischoiceset,
                                map(dictifycodeblock,
                                    map(getcodeblock,
                                        filter(iscodeblock, self.cleaned_data['doc'])))))

        pages = makepages(self.cleaned_data['doc'])
        pages_as_lists_of_dicts = [[dictifycodeblock(getcodeblock(i))
            for i in page if iscodeblock(i)] for page in pages]

        asker, modified = get_or_modify(Asker, {"slug": asker.slug}, meta)

        # flatten keyvals into the main dictionary-per-question
        [map(lambda x: x.update(x['keyvals']), page) for page in pages_as_lists_of_dicts]
        [map(lambda x: x.pop('keyvals'), page) for page in pages_as_lists_of_dicts]

        # make it so that we can pull extra kwargs in the markdown code block into widget_kwargs or field_kwargs
        assign_widget_kwargs = lambda x: x.update({'widget_kwargs': json.dumps(pull_out_options(x, "width min max value values units".split()))})
        [map(assign_widget_kwargs, page) for page in pages_as_lists_of_dicts]

        # select out just the questions
        questions_by_pages = [filter(isquestion, i) for i in pages_as_lists_of_dicts]
        [map(process_question_showif, page) for page in pages_as_lists_of_dicts]

        pages = [get_or_modify(AskPage, {"asker": asker, "order": i}, {})
            for i, j in enumerate(questions_by_pages)]

        for askpage, questions in zip(pages, questions_by_pages):
            for n, i in enumerate(questions):

                i.update({"page": askpage[0], "order": n})
                i = {k: _keyvalloader(v) for k, v in i.items()}

                if i.get("choiceset", None):
                    i['choiceset'], created = ChoiceSet.objects.get_or_create(name=i['choiceset'])

                # allow django variables
                i.update({'text': i.get('text').replace("[[", "{{")})
                i.update({'text': i.get('text').replace("]]", "}}")})

                # set a default type
                # raise Exception(i)
                i.update({'q_type': i.get('type', "instruction")})
                get_or_modify(Question, {"variable_name": i['variable_name']}, i)

        # delete unused questions... too dangerous?
        variable_names = map(lambda x: x.get('variable_name'), chain(*questions_by_pages))
        unused_questions = [i for i in asker.questions() if i.variable_name not in variable_names]

        [i.delete() for i in unused_questions]
        # delete unused pages too
        [i.delete() for i in asker.askpage_set.all()[len(questions_by_pages):]]


@group_required(['Researchers', 'Research Assistants'])
def edit_markdown_survey(request, asker_id):

    asker = Asker.objects.get(id=asker_id)

    form = MarkdownEditForm(request.POST or None, asker=asker)
    if form.is_valid():
        form.save(asker)
        return HttpResponseRedirect(reverse('edit_markdown_survey', args=(asker.id,)))

    return render_to_response(
        'admin/ask/markdown_preview.html', {'form': form, 'asker': asker},
        context_instance=RequestContext(request))
